{"version":3,"file":"react-infinite-list.js","names":[],"mappings":"","sources":["react-infinite-list.jsx"],"sourcesContent":["(function (root, factory) {\r\n    if (typeof define === 'function' && define.amd) {\r\n        define(['react', 'underscore'], factory);\r\n    } else if (typeof exports === 'object') {\r\n        module.exports = factory(require('react'), require('underscore'));\r\n    } else {\r\n        root.InfiniteListComponent = factory(root.React);\r\n    }\r\n}(this, function (React, _) {\r\n\r\n  var getWindowHeight,\r\n      nextFrame,\r\n      cancelFrame,\r\n      DEFAULTS,\r\n      InfiniteListComponent,\r\n      InfiniteListItem;\r\n\r\n  // Utility\r\n\r\n  getWindowHeight = function() { return  window.innerHeight };\r\n\r\n  nextFrame = (function () {\r\n     return window.requestAnimationFrame ||\r\n        window.webkitRequestAnimationFrame ||\r\n        window.mozRequestAnimationFrame ||\r\n        window.oRequestAnimationFrame ||\r\n        window.msRequestAnimationFrame || function (callback) {\r\n           return window.setTimeout(callback, 1);\r\n        };\r\n  })();\r\n\r\n  cancelFrame = (function () {\r\n     return window.cancelRequestAnimationFrame ||\r\n        window.webkitCancelAnimationFrame ||\r\n        window.webkitCancelRequestAnimationFrame ||\r\n        window.mozCancelRequestAnimationFrame ||\r\n        window.oCancelRequestAnimationFrame ||\r\n        window.msCancelRequestAnimationFrame ||\r\n        window.clearTimeout;\r\n  })();\r\n\r\n\r\n  // Default Config\r\n  DEFAULTS = {};\r\n  DEFAULTS.DEFAULT_ITEM_HEIGHT = 35;\r\n  DEFAULTS.MARGIN_BOTTOM = 0;\r\n  DEFAULTS.MARGIN_OUT_SCREEN = 10 * DEFAULTS.DEFAULT_ITEM_HEIGHT;\r\n\r\n\r\n\r\n   var InfiniteListComponent = React.createClass({\r\n\r\n     //\r\n     // Life Cycle\r\n     //\r\n\r\n     componentDidMount : function () {\r\n\r\n       this._configuration = _.extend(DEFAULTS, this.props.config);\r\n       this.setState({\r\n         initialOffsetTop : this.getDOMNode().offsetTop,\r\n         viewPortHeight : (getWindowHeight() - this.getDOMNode().offsetTop - this._configuration.MARGIN_BOTTOM),\r\n         listHeight : this.getListFullHeight()\r\n       });\r\n\r\n       this.keepDisplayInSync();\r\n     },\r\n\r\n     getInitialState : function (){\r\n       return {\r\n         startIdx : 0,\r\n         endIdx : 30, /* FIXME */\r\n         offsetTop : 0,\r\n         differential : false\r\n       }\r\n     },\r\n\r\n     componentWillReceiveProps : function () {\r\n        this.setState({\r\n          viewPortHeight : (getWindowHeight() - this.getDOMNode().offsetTop - this._configuration.MARGIN_BOTTOM),\r\n          listHeight : this.getListFullHeight()\r\n        });\r\n     },\r\n\r\n     componentWillUpdate : function (nextProps, nextState) {\r\n\r\n       // Compare states, maybe measure  height ? and compute list virtual height\r\n\r\n       var refName, isRendered, wasDisplayed, willBeAdded, offsetCorrection, instance_;\r\n\r\n       if (!nextState.differential) { return; }\r\n\r\n       instance_ = this;\r\n       offsetCorrection = 0;\r\n\r\n       console.log('UPDATE LOOP TRIGGERED');\r\n\r\n       _.each(this.props.children, function (ReactCpnt, idx) {\r\n\r\n          var ref, wasDisplayed, isDisplayed, hasBeenRemovedBefore, hasBeenAddedBefore, direction, elementAppeared, elementDisappeared;\r\n\r\n          refName = \"infinite-list-item-\" + idx;\r\n          ref = instance_.refs[refName];\r\n\r\n          wasDisplayed = idx >= this.state.startIdx && idx <= this.state.endIdx;\r\n          isDisplayed = idx >= nextState.startIdx && idx <= nextState.endIdx;\r\n\r\n          elementAppeared = isDisplayed && !wasDisplayed;\r\n          elementDisappeared = !isDisplayed && wasDisplayed;\r\n\r\n          direction = nextState.startIdx > this.state.startIdx ? 'down' : 'up';\r\n\r\n\r\n          // Buffering did not occur correctly\r\n          if (!ref || !ref._cachedHeight){ return; }\r\n\r\n\r\n          if (direction === 'up' && elementAppeared && idx <= this.state.startIdx) {\r\n             offsetCorrection = offsetCorrection - ref._cachedHeight;\r\n          }\r\n\r\n\r\n          if (direction === 'down'&& elementDisappeared && idx < nextState.startIdx) {\r\n            offsetCorrection = offsetCorrection + ref._cachedHeight;\r\n          }\r\n\r\n       }, this);\r\n\r\n\r\n       // Get correct offset top\r\n       nextState.offsetTop = nextState.offsetTop + offsetCorrection;\r\n\r\n     },\r\n\r\n     componentDidUpdate : function (prevProps, prevState) {\r\n        // Must result for next compare\r\n        this.state.listRealHeight = this.refs['list-rendered'].getDOMNode().scrollHeight;\r\n        this.state.offsetBottom = this.state.offsetTop + this.state.listRealHeight;\r\n     },\r\n\r\n     render : function () {\r\n\r\n       var wrapperStyle, positionningDivStyle, listSizerStyle, startIdx, endIdx, instance_;\r\n\r\n       if (!this.state.viewPortHeight) { return (<div></div>) }\r\n\r\n       this.oldScroll =  this.getScroll();\r\n       instance_ = this;\r\n\r\n       wrapperStyle = {\r\n          height : this.state.viewPortHeight,\r\n          webkitOverflowScrolling : 'touch',\r\n          overflowY:'auto',\r\n          width:'100%',\r\n          position:'relative'\r\n        };\r\n\r\n       positionningDivStyle = {\r\n         WebkitTransform : 'translate(0, ' + (this.state.offsetTop||0) + 'px)',\r\n         MozTransform : 'translate(0, ' + (this.state.offsetTop||0) + 'px)'\r\n       };\r\n\r\n       listSizerStyle = {\r\n         height : this.state.listHeight\r\n       };\r\n\r\n       startIdx = this.state.startIdx;\r\n       endIdx = this.state.endIdx;\r\n\r\n\r\n\r\n       var infiniteChildren = _.map(this.props.children, function (ReactCpnt, idx) {\r\n\r\n         var refName, isRendered, isDisplayed;\r\n\r\n         if (idx < startIdx-20) { return; }\r\n         if (idx > endIdx+20) { return; }\r\n\r\n         refName = \"infinite-list-item-\" + idx;\r\n         isDisplayed = idx >= startIdx && idx <= endIdx;\r\n\r\n         return (\r\n          <InfiniteListItem rendered={isDisplayed} key={idx} ref={refName}>\r\n            {ReactCpnt}\r\n          </InfiniteListItem>\r\n         );\r\n       });\r\n\r\n       return (\r\n         <div style={wrapperStyle}>\r\n          <div style={listSizerStyle}>\r\n            <div className=\"hidden-infinite-list-buffer\" refs=\"hidden-buffer\"></div>\r\n            <div style={positionningDivStyle} ref=\"list-rendered\">\r\n              {infiniteChildren}\r\n            </div>\r\n          </div>\r\n        </div>);\r\n     },\r\n\r\n\r\n    /*\r\n    * Read the scroll position perodically to update display when neededed\r\n    * Synchronise update with browser frames\r\n    */\r\n    keepDisplayInSync : function () {\r\n      var instance_ = this;\r\n      function repos() {\r\n          nextFrame(function () { instance_.rePositionList.call(instance_, instance_.getScroll()); });\r\n       }\r\n      this.displaySyncInterval =  window.setInterval(repos, 1); // Get rid of those 50 ms ?\r\n    },\r\n\r\n    tearDownDisplayUpdate : function () {\r\n      window.clearInterval(this.displaySyncInterval);\r\n    },\r\n\r\n\r\n    getScroll : function () {\r\n      return this.getDOMNode().scrollTop;\r\n    },\r\n\r\n    getListFullHeight: function () {\r\n      var fullLength = this.props.children.length;\r\n      return (fullLength * this._configuration.DEFAULT_ITEM_HEIGHT) || 0;\r\n    },\r\n\r\n    //\r\n    //  Real impl\r\n    //\r\n    rePositionList: function (newScroll) {\r\n\r\n       var isGoingUp = newScroll < this.oldScroll;\r\n       var isGoingDown = newScroll > this.oldScroll;\r\n\r\n       var isBeforeTop = (newScroll < this.state.offsetTop);\r\n       var isAfterBottom = ((newScroll + this.state.viewPortHeight) > this.state.offsetBottom);\r\n\r\n       var hasReachedTopOfTheList = (this.state.startIdx == 0);\r\n       var hasReachedBottomOfTheList = (this.state.endIdx == (this.props.children.length));\r\n\r\n       this.oldScroll = newScroll;\r\n\r\n       if (isGoingUp && hasReachedTopOfTheList && this.state.startIdx == 0) {\r\n          return;\r\n       }\r\n\r\n       if (isGoingDown && hasReachedBottomOfTheList) {\r\n          return;\r\n       }\r\n\r\n       if ((isBeforeTop || isAfterBottom )) {\r\n          this.approximateInsertion(newScroll);\r\n       } else if (isGoingDown) {\r\n          this.repositionListDown(newScroll);\r\n       } else if (isGoingUp) {\r\n          this.repositionListUp(newScroll);\r\n       }\r\n\r\n    },\r\n\r\n    repositionListUp: function (newScroll) {\r\n\r\n       var targetOffsetTop, move, willReachTop, isTooCloseToBottom, instance_;\r\n\r\n       instance_ = this;\r\n\r\n       // Check if the bottom of the list is not too close\r\n       isTooCloseToBottom = this.state.offsetBottom < newScroll + this.state.viewPortHeight +  ( this._configuration.MARGIN_OUT_SCREEN / 2)\r\n\r\n       // Where we want the new offset top to be\r\n       targetOffsetTop = newScroll - this._configuration.MARGIN_OUT_SCREEN * 2;\r\n\r\n       // Compute the move\r\n       move =  Math.max( (this.state.offsetTop - targetOffsetTop) / this._configuration.DEFAULT_ITEM_HEIGHT, 0);\r\n\r\n       // Beginning of line\r\n       willReachTop = (this.state.startIdx-move) <= 0;\r\n\r\n       if ((!isTooCloseToBottom && move > 3) || willReachTop) {\r\n\r\n         move = Math.min(move, this.state.startIdx); // Easy one\r\n\r\n         var nextIndexes = this.computeNextIndexesAndBuffer('up', move);\r\n         nextFrame(function () {\r\n           // Update rendering on next available frame\r\n           instance_.setState({ startIdx : nextIndexes.nextStartIdx, endIdx : nextIndexes.nextEndIdx, differential : true });\r\n         });\r\n\r\n       }\r\n\r\n     },\r\n\r\n\r\n     repositionListDown: function (newScroll) {\r\n          var instance_, targetOffsetBottom, move, maxMove, isTooCloseToTop, willReachedBottom;\r\n\r\n          instance_ = this;\r\n\r\n          // Check if top of the list is not too close\r\n          isTooCloseToTop = ( newScroll - this.offsetTop ) < (this._configuration.MARGIN_OUT_SCREEN / 2);\r\n\r\n          // Where list is supposed to end now\r\n          targetOffsetBottom = newScroll + this.state.viewPortHeight + this._configuration.MARGIN_OUT_SCREEN * 2;\r\n\r\n          // Now we can compute the desired move\r\n          move = Math.max( (targetOffsetBottom - this.state.offsetBottom) / this._configuration.DEFAULT_ITEM_HEIGHT , 0);\r\n\r\n          // Another move\r\n          willReachedBottom = (this.state.endIdx + move) >= this.props.children.length;\r\n\r\n\r\n          if ((!isTooCloseToTop && move>3) || willReachedBottom) {\r\n\r\n             move = Math.min(move, (this.props.children.length) - this.state.endIdx);\r\n\r\n             var nextIndexes = this.computeNextIndexesAndBuffer('down', move);\r\n             nextFrame(function () {\r\n               // Update rendering on next available frame\r\n               instance_.setState({ startIdx : nextIndexes.nextStartIdx, endIdx : nextIndexes.nextEndIdx, differential : true });\r\n             });\r\n\r\n          }\r\n     },\r\n\r\n\r\n     approximateInsertion: function (newScroll) {\r\n\r\n        var fullLength, fullSize, startPosition, endPosition;\r\n\r\n        fullLength = this.props.children.length;\r\n\r\n        startPosition = Math.round((newScroll * fullLength) / this.getListFullHeight());\r\n        endPosition = Math.round(startPosition + 30);\r\n\r\n        this.offsetTop = newScroll - this.state.viewPortHeight;\r\n        this.offsetTop <= 0 ? (this.offsetTop = 0) : (this.offsetTop = this.offsetTop);\r\n\r\n        this.setState({\r\n          startIdx : startPosition,\r\n          endIdx : endPosition,\r\n          offsetTop : this.offsetTop,\r\n          differential : false\r\n        });\r\n\r\n     },\r\n\r\n     /*\r\n     *  From a move, compute the new position\r\n     *  Measure the size of the newly added elements and recompute offset top\r\n     *  Next rendering cycle will use that position, cache size in items when they are rendered\r\n     */\r\n     computeNextIndexesAndBuffer : function (direction, move, newScroll) {\r\n\r\n       var instance_, startRenderIdx, endRenderIdx, toRender, rendering, representativeHeight, nextStartIdx, nextEndIdx, marginStart;\r\n\r\n      instance_ = this;\r\n      representativeHeight = 0;\r\n\r\n       if (direction === 'up') {\r\n\r\n         // Compute new indexes\r\n         nextStartIdx = this.state.startIdx - move;\r\n         nextEndIdx = this.state.endIdx - move;\r\n\r\n         // Compute new element that will be rendered\r\n         startRenderIdx = this.state.endIdx;\r\n         endRenderIdx = this.state.endIdx + move;\r\n\r\n       } else if (direction === 'down') {\r\n\r\n         nextStartIdx = this.state.startIdx + move;\r\n         nextEndIdx = this.state.endIdx + move;\r\n\r\n         startRenderIdx = this.state.startIdx - move;\r\n         endRenderIdx = this.state.startIdx;\r\n       }\r\n\r\n       nextStartIdx = Math.round(nextStartIdx);\r\n       nextEndIdx = Math.round(nextEndIdx);\r\n\r\n       toRender = this.props.children.slice(startRenderIdx, endRenderIdx);\r\n\r\n       // Force new children to render once ( offscreen) so they can cache their size\r\n       _.each( toRender, function (element, idx) {\r\n         if (instance_.refs['infinite-list-item-' + (startRenderIdx + idx)]\r\n             && !instance_.refs['infinite-list-item-' + (startRenderIdx + idx)]._cachedHeight) {\r\n          instance_.refs['infinite-list-item-' + (startRenderIdx + idx)].setState({ rendered : true, buffer : true });\r\n         }\r\n       }, this);\r\n\r\n       return { nextStartIdx : nextStartIdx, nextEndIdx : nextEndIdx };\r\n     }\r\n\r\n\r\n });\r\n\r\n\r\n\r\n  /*\r\n  * Wrapper for children components\r\n  * Used to cache the size of elements\r\n  */\r\n  var InfiniteListItem = React.createClass({\r\n\r\n\r\n    // Cache the height of the element\r\n    componentDidMount : function () {\r\n      if (this.getDOMNode()) {\r\n        this._cachedHeight = this.getDOMNode().offsetHeight;\r\n      }\r\n    },\r\n\r\n    componentDidUpdate : function () {\r\n      if (this.getDOMNode()) {\r\n        this._cachedHeight = this.getDOMNode().offsetHeight;\r\n      }\r\n    },\r\n\r\n    shouldComponentUpdate : function (nextProps, nextState) {\r\n\r\n      var shouldComponentUpdate;\r\n      if (!this.props) {\r\n        return true;\r\n      }\r\n\r\n      shouldComponentUpdate = this.props.rendered != nextProps.rendered;\r\n\r\n      return shouldComponentUpdate;\r\n    },\r\n\r\n    render : function () {\r\n\r\n      var style;\r\n\r\n      if (!this.props.rendered) {\r\n        return false;\r\n      }\r\n\r\n      style = {};\r\n      style.overflow = 'hidden'\r\n\r\n      if (this.props.buffer) {\r\n        style.position = absolute;\r\n        style.top = '-1000px;';\r\n      }\r\n\r\n      return (<div style={style}>{this.props.children}</div>);\r\n    }\r\n  });\r\n\r\n  return InfiniteListComponent;\r\n\r\n}));\r\n"],"sourceRoot":"/source/"}